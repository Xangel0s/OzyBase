package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"runtime"
	"sync"
	"time"

	"github.com/Xangel0s/OzyBase/internal/core"
	"github.com/Xangel0s/OzyBase/internal/data"
	"github.com/Xangel0s/OzyBase/internal/mailer"
	"github.com/Xangel0s/OzyBase/internal/realtime"
	"github.com/labstack/echo/v4"
	"github.com/shirou/gopsutil/v3/cpu"
	"github.com/shirou/gopsutil/v3/mem"
)

var startTime = time.Now()

// LogEntry represents a single request log
type LogEntry struct {
	ID        string    `json:"id"`
	Time      string    `json:"time"`
	Method    string    `json:"method"`
	Path      string    `json:"path"`
	Status    int       `json:"status"`
	Latency   string    `json:"latency"`
	IP        string    `json:"ip"`
	Country   string    `json:"country,omitempty"`
	City      string    `json:"city,omitempty"`
	Timestamp time.Time `json:"-"`
}

// Metrics holds in-memory activity stats
type Metrics struct {
	sync.RWMutex
	DbRequests      int
	AuthRequests    int
	StorageRequests int
	DbHistory       []int
	AuthHistory     []int
	StorageHistory  []int
	RealtimeHistory []int
	CpuHistory      []float64
	RamHistory      []float64
	Logs            []LogEntry
}

// Handler holds dependencies for HTTP handlers
type Handler struct {
	DB           *data.DB
	Metrics      *Metrics
	Broker       *realtime.Broker
	Webhooks     *realtime.WebhookDispatcher
	Geo          *core.GeoService
	Mailer       mailer.Mailer
	Integrations *realtime.WebhookIntegration
	Auth         *core.AuthService // Added for direct token generation
}

// NewHandler creates a new Handler with the given dependencies
func NewHandler(db *data.DB, broker *realtime.Broker, webhooks *realtime.WebhookDispatcher, mailSvc mailer.Mailer) *Handler {
	m := &Metrics{
		DbHistory:       make([]int, 60),
		AuthHistory:     make([]int, 60),
		StorageHistory:  make([]int, 60),
		RealtimeHistory: make([]int, 60),
		CpuHistory:      make([]float64, 60),
		RamHistory:      make([]float64, 60),
		Logs:            make([]LogEntry, 0, 100),
	}
	// Start history rotator
	go m.rotateHistory(db)

	return &Handler{
		DB:           db,
		Metrics:      m,
		Broker:       broker,
		Webhooks:     webhooks,
		Geo:          core.NewGeoService(db),
		Mailer:       mailSvc,
		Integrations: realtime.NewWebhookIntegration(db.Pool),
	}
}

// AddLog adds a new log entry to the metrics
func (m *Metrics) AddLog(entry LogEntry) {
	m.Lock()
	defer m.Unlock()

	// Prepend to show latest first
	m.Logs = append([]LogEntry{entry}, m.Logs...)
	if len(m.Logs) > 100 {
		m.Logs = m.Logs[:100]
	}
}

func (m *Metrics) rotateHistory(db *data.DB) {
	ticker := time.NewTicker(10 * time.Second)
	for range ticker.C {
		m.Lock()
		// Rotate all histories
		copy(m.DbHistory[0:], m.DbHistory[1:])
		m.DbHistory[59] = m.DbRequests
		m.DbRequests = 0

		copy(m.AuthHistory[0:], m.AuthHistory[1:])
		m.AuthHistory[59] = m.AuthRequests
		m.AuthRequests = 0

		copy(m.StorageHistory[0:], m.StorageHistory[1:])
		m.StorageHistory[59] = m.StorageRequests
		m.StorageRequests = 0

		copy(m.RealtimeHistory[0:], m.RealtimeHistory[1:])
		var active int
		if err := db.Pool.QueryRow(context.Background(), "SELECT COUNT(*) FROM pg_stat_activity WHERE state = 'active'").Scan(&active); err == nil {
			m.RealtimeHistory[59] = active
		}

		// System Stats
		copy(m.CpuHistory[0:], m.CpuHistory[1:])
		if cpuPercentages, err := cpu.Percent(0, false); err == nil && len(cpuPercentages) > 0 {
			m.CpuHistory[59] = cpuPercentages[0]
		}

		copy(m.RamHistory[0:], m.RamHistory[1:])
		if v, err := mem.VirtualMemory(); err == nil {
			m.RamHistory[59] = v.UsedPercent
		}

		m.Unlock()
	}
}

// StartLogExporter starts a background worker to flush logs to SIEM
func (h *Handler) StartLogExporter(ctx context.Context) {
	ticker := time.NewTicker(30 * time.Second) // Flush every 30s
	defer ticker.Stop()

	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			h.flushLogsToSIEM(ctx)
		}
	}
}

func (h *Handler) flushLogsToSIEM(ctx context.Context) {
	// Get latest logs from memory buffer
	h.Metrics.RLock()
	if len(h.Metrics.Logs) == 0 {
		h.Metrics.RUnlock()
		return
	}

	// Create a copy to send
	logsToSend := make([]map[string]interface{}, len(h.Metrics.Logs))
	for i, log := range h.Metrics.Logs {
		logsToSend[i] = map[string]interface{}{
			"id":        log.ID,
			"time":      log.Time,
			"method":    log.Method,
			"path":      log.Path,
			"status":    log.Status,
			"latency":   log.Latency,
			"ip":        log.IP,
			"country":   log.Country,
			"city":      log.City,
			"timestamp": log.Timestamp,
		}
	}
	h.Metrics.RUnlock()

	// Send to Integrations service
	if h.Integrations != nil {
		_ = h.Integrations.SendLogBatch(ctx, logsToSend)
	}
}

// HealthResponse represents the health check response
type HealthResponse struct {
	Status    string `json:"status"`
	Database  string `json:"database"`
	Timestamp string `json:"timestamp"`
	Uptime    string `json:"uptime"`
	Memory    struct {
		Alloc      uint64 `json:"alloc_mb"`
		TotalAlloc uint64 `json:"total_alloc_mb"`
		Sys        uint64 `json:"sys_mb"`
		NumGC      uint32 `json:"num_gc"`
	} `json:"memory"`
}

// Health handles GET /api/health
func (h *Handler) Health(c echo.Context) error {
	ctx, cancel := context.WithTimeout(c.Request().Context(), 2*time.Second)
	defer cancel()

	dbStatus := "connected"
	if err := h.DB.Health(ctx); err != nil {
		dbStatus = "disconnected"
	}

	status := "ok"
	if dbStatus == "disconnected" {
		status = "degraded"
	}

	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	resp := HealthResponse{
		Status:    status,
		Database:  dbStatus,
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Uptime:    time.Since(startTime).String(),
	}
	resp.Memory.Alloc = m.Alloc / 1024 / 1024
	resp.Memory.TotalAlloc = m.TotalAlloc / 1024 / 1024
	resp.Memory.Sys = m.Sys / 1024 / 1024
	resp.Memory.NumGC = m.NumGC

	return c.JSON(http.StatusOK, resp)
}

// GetStats handles GET /api/project/stats
func (h *Handler) GetStats(c echo.Context) error {
	h.Metrics.RLock()
	defer h.Metrics.RUnlock()

	return c.JSON(http.StatusOK, map[string]interface{}{
		"db":       h.Metrics.DbHistory,
		"auth":     h.Metrics.AuthHistory,
		"storage":  h.Metrics.StorageHistory,
		"realtime": h.Metrics.RealtimeHistory,
		"cpu":      h.Metrics.CpuHistory,
		"ram":      h.Metrics.RamHistory,
		"summary": map[string]int{
			"db":      h.Metrics.DbRequests,
			"auth":    h.Metrics.AuthRequests,
			"storage": h.Metrics.StorageRequests,
		},
	})
}

// GetLogs handles GET /api/project/logs
func (h *Handler) GetLogs(c echo.Context) error {
	rows, err := h.DB.Pool.Query(c.Request().Context(), `
		SELECT id, created_at, method, path, status, latency_ms, ip_address, country, city
		FROM _v_audit_logs
		ORDER BY created_at DESC
		LIMIT 100
	`)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	defer rows.Close()

	var logs []LogEntry
	for rows.Next() {
		var l LogEntry
		var createdAt time.Time
		var latencyMs int64
		if err := rows.Scan(&l.ID, &createdAt, &l.Method, &l.Path, &l.Status, &latencyMs, &l.IP, &l.Country, &l.City); err == nil {
			l.Time = createdAt.Format("15:04:05")
			l.Latency = fmt.Sprintf("%dms", latencyMs)
			logs = append(logs, l)
		}
	}

	if logs == nil {
		logs = []LogEntry{}
	}

	return c.JSON(http.StatusOK, logs)
}

// GetSecurityPolicies handles GET /api/project/security/policies
func (h *Handler) GetSecurityPolicies(c echo.Context) error {
	rows, err := h.DB.Pool.Query(c.Request().Context(), "SELECT type, config FROM _v_security_policies")
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	defer rows.Close()

	policies := make(map[string]interface{})
	for rows.Next() {
		var pType string
		var config []byte
		if err := rows.Scan(&pType, &config); err == nil {
			var configMap interface{}
			_ = json.Unmarshal(config, &configMap)
			policies[pType] = configMap
		}
	}

	// Default geo_fencing if not exists
	if _, ok := policies["geo_fencing"]; !ok {
		policies["geo_fencing"] = map[string]interface{}{
			"enabled":           false,
			"allowed_countries": []string{},
		}
	}

	return c.JSON(http.StatusOK, policies)
}

// UpdateSecurityPolicy handles POST /api/project/security/policies
func (h *Handler) UpdateSecurityPolicy(c echo.Context) error {
	var req struct {
		Type   string                 `json:"type"`
		Config map[string]interface{} `json:"config"`
	}

	if err := c.Bind(&req); err != nil {
		return err
	}

	configJSON, _ := json.Marshal(req.Config)

	_, err := h.DB.Pool.Exec(c.Request().Context(), `
		INSERT INTO _v_security_policies (type, config, updated_at)
		VALUES ($1, $2, NOW())
		ON CONFLICT (type) DO UPDATE SET config = $2, updated_at = NOW()
	`, req.Type, configJSON)

	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	// Invalidate cache if it's geo_fencing
	if req.Type == "geo_fencing" {
		h.Geo.InvalidatePolicy()
	}

	return c.JSON(http.StatusOK, map[string]string{"status": "updated"})
}

// SecurityStats represents data for the security dashboard
type SecurityStats struct {
	TotalChecks     int64           `json:"total_checks"`
	AllowedRequests int64           `json:"allowed_requests"`
	BlockedRequests int64           `json:"blocked_requests"`
	TopCountries    []GeoStat       `json:"top_countries"`
	TopIPs          []IPStat        `json:"top_ips"`
	AlertsTimeline  []TimelineEvent `json:"alerts_timeline"`
	TotalBreaches   int64           `json:"total_breaches"`
	LastBreachAt    string          `json:"last_breach_at"`
}

type GeoStat struct {
	Country string `json:"country"`
	Count   int64  `json:"count"`
}

type IPStat struct {
	IP    string `json:"ip"`
	Count int64  `json:"count"`
}

type TimelineEvent struct {
	Time  string `json:"time"`
	Count int64  `json:"count"`
}

// GetSecurityStats handles GET /api/project/security/stats
func (h *Handler) GetSecurityStats(c echo.Context) error {
	ctx := c.Request().Context()
	var stats SecurityStats

	// 1. Total Checks
	_ = h.DB.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM _v_audit_logs").Scan(&stats.TotalChecks)

	// 2. Blocked vs Allowed (Rough estimate from alerts)
	_ = h.DB.Pool.QueryRow(ctx, "SELECT COUNT(*) FROM _v_security_alerts").Scan(&stats.BlockedRequests)
	stats.AllowedRequests = stats.TotalChecks - stats.BlockedRequests
	stats.TotalBreaches = stats.BlockedRequests

	// 3. Top Countries
	rows, _ := h.DB.Pool.Query(ctx, `
		SELECT country, COUNT(*) as count 
		FROM _v_audit_logs 
		WHERE country != 'Localhost' AND country != 'Internal'
		GROUP BY country 
		ORDER BY count DESC 
		LIMIT 5
	`)
	for rows.Next() {
		var g GeoStat
		if err := rows.Scan(&g.Country, &g.Count); err == nil {
			stats.TopCountries = append(stats.TopCountries, g)
		}
	}
	rows.Close()

	// 4. Top IPs
	rows, _ = h.DB.Pool.Query(ctx, `
		SELECT ip_address, COUNT(*) as count 
		FROM _v_audit_logs 
		GROUP BY ip_address 
		ORDER BY count DESC 
		LIMIT 5
	`)
	for rows.Next() {
		var i IPStat
		if err := rows.Scan(&i.IP, &i.Count); err == nil {
			stats.TopIPs = append(stats.TopIPs, i)
		}
	}
	rows.Close()

	// 5. Timeline (Last 24 hours of alerts)
	rows, _ = h.DB.Pool.Query(ctx, `
		SELECT TO_CHAR(created_at, 'HH24:00') as hour, COUNT(*) 
		FROM _v_security_alerts 
		WHERE created_at > NOW() - INTERVAL '24 hours'
		GROUP BY hour 
		ORDER BY hour ASC
	`)
	for rows.Next() {
		var t TimelineEvent
		if err := rows.Scan(&t.Time, &t.Count); err == nil {
			stats.AlertsTimeline = append(stats.AlertsTimeline, t)
		}
	}
	rows.Close()

	// 6. Last Breach
	h.DB.Pool.QueryRow(ctx, "SELECT created_at FROM _v_security_alerts ORDER BY created_at DESC LIMIT 1").Scan(&stats.LastBreachAt)

	return c.JSON(http.StatusOK, stats)
}

// GetNotificationRecipients handles GET /api/project/security/notifications
func (h *Handler) GetNotificationRecipients(c echo.Context) error {
	rows, err := h.DB.Pool.Query(c.Request().Context(), `
		SELECT id, email, alert_types, is_active, created_at 
		FROM _v_security_notification_recipients 
		ORDER BY created_at DESC
	`)
	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}
	defer rows.Close()

	type Recipient struct {
		ID         string   `json:"id"`
		Email      string   `json:"email"`
		AlertTypes []string `json:"alert_types"`
		IsActive   bool     `json:"is_active"`
		CreatedAt  string   `json:"created_at"`
	}

	var recipients []Recipient
	for rows.Next() {
		var r Recipient
		if err := rows.Scan(&r.ID, &r.Email, &r.AlertTypes, &r.IsActive, &r.CreatedAt); err == nil {
			recipients = append(recipients, r)
		}
	}

	return c.JSON(http.StatusOK, recipients)
}

// AddNotificationRecipient handles POST /api/project/security/notifications
func (h *Handler) AddNotificationRecipient(c echo.Context) error {
	var req struct {
		Email      string   `json:"email"`
		AlertTypes []string `json:"alert_types"`
	}

	if err := c.Bind(&req); err != nil {
		return err
	}

	if req.Email == "" {
		return c.JSON(http.StatusBadRequest, map[string]string{"error": "email is required"})
	}

	_, err := h.DB.Pool.Exec(c.Request().Context(), `
		INSERT INTO _v_security_notification_recipients (email, alert_types)
		VALUES ($1, $2)
	`, req.Email, req.AlertTypes)

	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusCreated, map[string]string{"status": "created"})
}

// DeleteNotificationRecipient handles DELETE /api/project/security/notifications/:id
func (h *Handler) DeleteNotificationRecipient(c echo.Context) error {
	id := c.Param("id")

	_, err := h.DB.Pool.Exec(c.Request().Context(), `
		DELETE FROM _v_security_notification_recipients WHERE id = $1
	`, id)

	if err != nil {
		return c.JSON(http.StatusInternalServerError, map[string]string{"error": err.Error()})
	}

	return c.JSON(http.StatusOK, map[string]string{"status": "deleted"})
}
